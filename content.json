[{"title":"一次移动端重构","date":"2018-01-03T08:25:40.000Z","path":"2018/01/03/一次移动端重构/","text":"接近年末，有一些空余时间，开始考虑对一个 vue1.x 版本的老项目进行重构 3个问题 现存的移动端适配方案很草率，是根据媒体查询做了一个简单的适配 打包构建非常速度慢，每次都是全局构建 没有做代码风格检测和测试 3个解法 选用 rem 或 vm 方案进行移动端适配 采用webpack打包，后续优化打包速度 加入eslint检查（在standard标准配置上修改），加入测试 待续","tags":[{"name":"前端工程","slug":"前端工程","permalink":"http://yoursite.com/tags/前端工程/"},{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/性能优化/"},{"name":"重构","slug":"重构","permalink":"http://yoursite.com/tags/重构/"}]},{"title":"移动端适配方案之rem适配","date":"2017-11-01T08:25:40.000Z","path":"2017/11/01/移动端适配方案之rem适配/","text":"这篇博文不讲概念，基本上是学习了网上文章后的最佳实践 问题 设计师给你一张视觉稿，要怎么样做到移动端设备适配呢？ 准备材料 淘宝无线前端 lib-flexible 让设计师准备两份切图@2x @3x \b步骤 删除常规的移动端 meta 标签（重要） 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;著作权归作者所有。 加上 flexbible meta 标签（可选） 1&lt;meta content=&quot;maximum-dpr=2&quot; name=&quot;flexible&quot; /&gt; 引用 cdn 地址，插入到 head 中 1234&lt;head&gt;...&lt;script src=&quot;http://g.tbcdn.cn/mtb/lib-flexible/0.3.2/??flexible_css.js,flexible.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 把视觉稿中的px转换成rem工作中我们常见的视觉稿大小大至可为640、750、1125三种。不过flexible.js并没有限制只能用这三种，所以你还可以根据自身情况来调整，具体如何转换，我们以视觉稿为640px的宽来举例子，把640px分为100份，每一份称为一个单位a，那么每个a就是6.4px，而1rem单位被认定为10a，此时，1rem=1(a)X10X6.4(px)即64px。 123640px/100=6.4px 1个单位a为6.4px1rem = 10a 1rem单位被认定为10a1rem = 1(a)*10*6.4(px) = 64px 因此，对于视觉稿上的元素的尺寸换算，只需要原始px值除以rem基准px值(此例子中为64px)即可。例如240px 120px的元素，最后转换为3.75rem 1.875rem。 内容字体不要使用 rem工作中做完一个触屏版的页面后，我们会拿iPhone5s、iPhone6、iPhone6s等手机进行测试，他们都是Retina屏，我们当然希望在这些手机型号上看到的文本字号是相同的。也就是说，我们不希望文本在Retina屏幕下变小，另外，我们希望在大屏手机上看到更多文本（例如iPhone7、iPhone7Plus）。另外，现在绝大多数的字体文件都自带一些点阵尺寸，通常是16px和24px，都是偶数，所以我们不希望出现13px和15px这样的奇葩尺寸。如此一来，就决定了在制作H5的页面中，rem并不适合用到段落文本上。所以在Flexible整个适配方案中，考虑文本还是使用px作为单位。只不过使用[data-dpr]属性来区分不同dpr下的文本字号大小。1234567891011div &#123; width: 1rem; height: 0.4rem; font-size: 12px; // 默认写上dpr为1的fontSize&#125;[data-dpr=&quot;2&quot;] div &#123; font-size: 24px;&#125;[data-dpr=&quot;3&quot;] div &#123; font-size: 36px;&#125; 为了能更好的利于开发，在实际开发中，我们可以定制一个font-dpr()这样的Sass混合宏：1234567891011@mixin font-dpr($font-size)&#123; font-size: $font-size; [data-dpr=&quot;2&quot;] &amp; &#123; font-size: $font-size * 2; &#125; [data-dpr=&quot;3&quot;] &amp; &#123; font-size: $font-size * 3; &#125;&#125; 有了这样的混合宏之后，在开发中可以直接这样使用：1@include font-dpr(16px); \bRetina 屏幕下图片模糊处理准备两份切图1）在devicePixelRatio&lt;=2时，图片统一使用750设计稿的切图2）在devicePixelRatio&gt;=2时，图片统一使用750*1.5=1125，也就是所谓@3x设计稿的切图。借助html元素的data-dpr属性，可以轻松实现另一种媒介查询，以便在devicePixelRatio&gt;=2的时候启用@3x下的图片：123456.avatar &#123; background-image: url(&quot;../img/@2x/merzoo.png?v=@@version&quot;); [data-dpr=&quot;3&quot;] &amp; &#123; background-image: url(&quot;../img/@3x/merzoo.png?v=@@version&quot;); &#125;&#125; 当然，也可以使用一些插件进行自动替换 解决 retina 屏下 border: 1px 问题设计师想要的retina下border: 1px;，其实就是1物理像素宽。而对于css而言，可以认为是border: 0.5px;，这是retina下(dpr=2)下能显示的最小单位。然而，无奈并不是所有手机浏览器都能识别border: 0.5px;，ios7以下，android等其他系统里，0.5px会被当成为0px处理，那么如何实现这0.5px呢？最简单的一个做法就是这样(元素scale)：12345678910111213.scale&#123; position: relative;&#125;.scale:after&#123; content:&quot;&quot;; position: absolute; bottom:0px; left:0px; right:0px; border-bottom:1px solid #ddd; -webkit-transform:scaleY(.5); -webkit-transform-origin:0 0;&#125;","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"重构","slug":"重构","permalink":"http://yoursite.com/tags/重构/"},{"name":"移动端适配","slug":"移动端适配","permalink":"http://yoursite.com/tags/移动端适配/"}]},{"title":"由闭包到模块化——一起来实现一个模块加载器吧！","date":"2017-01-10T10:14:48.000Z","path":"2017/01/10/由闭包到模块化——一起来实现一个模块加载器吧！/","text":"今天看《你不知道的JavaScript》中模块化这一章，作者由闭包的特性引申到现代模块加载器的核心原理。为加深理解，小小的记录一下吧。 作用域和闭包作用域和闭包联手，可以制造出极大的威力。模块，就是其中的一种： 12345678910function foo() &#123; var something = &quot;cool&quot;; var another = [1, 2, 3]; function doSomething() &#123; console.log( something ); &#125; function doAnother() &#123; console.log( another.join( &quot; ! &quot; ) ); &#125;&#125; 正如在这段代码中所看到的，这里并没有明显的闭包，只有两个私有数据变量something和another，以及doSomething() 和doAnother() 两个内部函数，它们的词法作用域（而这就是闭包）也就是foo() 的内部作用域。 现在我们来做一些修改： 1234567891011121314151617function CoolModule() &#123; var something = &quot;cool&quot;; var another = [1, 2, 3]; function doSomething() &#123; console.log( something ); &#125; function doAnother() &#123; console.log( another.join( &quot; ! &quot; ) ); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;;&#125;var foo = CoolModule();foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3 很明显，foo就是一个模块的实例，而return的对象就是这个模块暴露出来的对象。但是这里有一个让人不爽的地方就是，每次生成一个模块都需要执行一次CoolModule这个函数。 加个IIFE试试我们通过IIFE（立即执行函数）将这个模块改造一下： 12345678910111213141516var foo = (function CoolModule() &#123; var something = &quot;cool&quot;; var another = [1, 2, 3]; function doSomething() &#123; console.log( something ); &#125; function doAnother() &#123; console.log( another.join( &quot; ! &quot; ) ); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;;&#125;)();foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3 是不是感觉顺眼多了？利用了IIFE的特性形成了一个很常见的单例模式，使我们想暴露出来的公共API可以很方便的调用和修改模块内部的函数和变量。 实现一个模块加载器大多数模块依赖加载器/ 管理器本质上都是将这种模块定义封装进一个友好的API。核心代码如下： 12345678910111213141516var MyModules = (function Manager() &#123; var modules = &#123;&#125;; function define(name, deps, impl) &#123; for (var i=0; i&lt;deps.length; i++) &#123; deps[i] = modules[deps[i]]; &#125; modules[name] = impl.apply( impl, deps ); &#125; function get(name) &#123; return modules[name]; &#125; return &#123; define: define, get: get &#125;;&#125;)(); 这段代码的核心是modules[name] = impl.apply(impl, deps)。为了模块的定义引入了包装函数（可以传入任何依赖），并且将返回值，也就是模块的API，储存在一个根据名字来管理的模块列表中。下面展示了如何使用它来定义模块： 1234567891011121314151617181920212223MyModules.define( &quot;bar&quot;, [], function() &#123; function hello(who) &#123; return &quot;Let me introduce: &quot; + who; &#125; return &#123; hello: hello &#125;;&#125;);MyModules.define( &quot;foo&quot;, [&quot;bar&quot;], function(bar) &#123; var hungry = &quot;hippo&quot;; function awesome() &#123; console.log( bar.hello( hungry ).toUpperCase() ); &#125; return &#123; awesome: awesome &#125;;&#125;);var bar = MyModules.get( &quot;bar&quot; );var foo = MyModules.get( &quot;foo&quot; );console.log( bar.hello( &quot;hippo&quot; )); // Let me introduce: hippofoo.awesome(); // LET ME INTRODUCE: HIPPO 由于闭包的特性，modules这个对象永远不会销毁，模块就可以达到垒增的效果。到目前为止，一个模块加载器就完成啦！","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"css3硬件加速小记","date":"2017-01-01T08:25:40.000Z","path":"2017/01/01/css3硬件加速小记/","text":"今天做新版的PC页面的时候，用了一些css3的变形动画（主要是一些hover效果），但是发现会出现一些掉帧卡顿的现象。最后通过transform3d开启硬件加速解决了该问题。 默认不会开启GPU加速一般来说，CSS animations, transforms 以及 transitions 不会自动开启GPU加速，而是由浏览器的缓慢的软件渲染引擎来执行。那我们怎样才可以切换到GPU模式呢，很多浏览器提供了某些触发的CSS规则。现在，像Chrome, FireFox, Safari, IE9+和最新版本的Opera都支持硬件加速，当它们检测到页面中某个DOM元素应用了某些CSS规则时就会开启，最显著的特征的元素的3D变换。其原理是创建一个新的层，对该层进行硬件加速。 1）用translate: transform3d(0,0,0)开启加速1234.test-box &#123; -webkit-transform: translate3d(0,0,0); transform: translate3d(0,0,0);&#125; 2）用transform: translateZ(0)开启加速适合不需要用到3d变换的场景，用此法可达到欺骗浏览器的效果。 1234567.test-box &#123; -webkit-transform: translateZ(0); -moz-transform: translateZ(0); -ms-transform: translateZ(0); -o-transform: translateZ(0); transform: translateZ(0);&#125; 硬件加速的注意点 GPU渲染会影响字体的抗锯齿效果。这是因为GPU和CPU具有不同的渲染机制，即使最终硬件加速停止了，文本还是会在动画期间显示得很模糊。 不能让每个元素都启用硬件加速，这样会暂用很大的内存，使页面会有很强的卡顿感。 避免嵌套太深，会导致父级元素不必要的重绘。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/性能优化/"}]},{"title":"flex布局小记","date":"2016-11-16T06:35:40.000Z","path":"2016/11/16/flex布局小记/","text":"最近一直在做移动端h5的页面，用的了大量的flex布局。遂整理整理几个常见的用法作为一篇笔记博文发出。 什么是flex布局 flex布局由w3c组织于2009年提出，旨在解决传统盒子模型布局中的多种局限性，提高布局的简洁性和便利性。 flex布局可以十分便利的构建响应式的页面。 目前绝大部分现代浏览器已经可以支持，移动端浏览器全面支持。 怎么使用flex布局12345&lt;div id=&quot;parent&quot;&gt; &lt;p class=&quot;child1&quot;&gt;1&lt;/p&gt; &lt;div class=&quot;child2&quot;&gt;2&lt;/div&gt; &lt;h3 class=&quot;child3&quot;&gt;3&lt;/h3&gt;&lt;/div&gt; 以示例结构为例，我们分别来实现以下5种常见布局（注释纯属偷懒）： 水平排列 123#parent&#123; display: flex; //关键代码&#125; 水平居中排列 1234#parent&#123; display: flex; //关键代码 justify-content: center; //水平居中代码&#125; 垂直排列 1234#parent&#123; display: flex; //关键代码 flex-direction: column; //纵向排布&#125; 垂直居中排列 12345#parent&#123; display: flex; //关键代码 flex-direction: column; //纵向排布 align-items: center; //垂直居中代码&#125; 垂直水平居中排列 12345#parent&#123; display: flex; //关键代码 justify-content: center; //水平居中代码 align-items: center; //垂直居中代码&#125; 两端固定宽度，中间自适应（圣杯布局） 123456789101112131415#parent&#123; display: flex; //关键代码&#125;.child1&#123; width:30px; height:50px;&#125;.child2&#123; flex: 1; // 等同于flex:1 1 0%; height:50px;&#125;.child3&#123; width:40px; height:50px;&#125; 未完待续…","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"NVM简明指南","date":"2016-10-26T14:01:29.000Z","path":"2016/10/26/NVM简明指南/","text":"本教程适用于windows用户 安装操作步骤 下载 nvm-windows 解压到一个全英文目录(建议存放在C盘) 修改settings文件 root =&gt; nvm.exe 的位置 path =&gt; nodejs的快捷方式的位置（与nvm文件夹平行或自选） arch =&gt; 32/64 （你操作系统位数） 加入环境变量 win + r =&gt; 输入sysdm.cpl =&gt; 高级-环境变量-用户变量 新建 NVM_HOME = root 新建 NVM_SYMLINK = path 测试变量是否成功 cmd 输入PATH查看所有的用户变量是否有更新 cmd 输入set xx查看你想要查看的变量地址是否正确，如set NVM_HOME 测试nvm是否安装成功 $nvm =&gt; nvm help … OK $nvm ls =&gt; 列出所有安装的node版本 $nvm use =&gt; 使用需要的node版本 $nvm install/uninstall =&gt; 安装卸载","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"前端工程","slug":"前端工程","permalink":"http://yoursite.com/tags/前端工程/"}]},{"title":"null和undefined的区别","date":"2016-06-20T08:51:29.000Z","path":"2016/06/20/null和undefined的区别/","text":"目前来说，null和undefined是基本同义的，只有一些细微差别。 null表示“没有对象”，即该处不应该有值。典型用法是： 作为函数的参数，表示该函数的参数不是对象。 作为原型链的终点。 1Object.getPrototypeOf(Object.getPrototypeOf) //null undefined表示“缺少值”，就是此处应该有一个值，但是还没有定义。 典型用法是: 变量被声明了，但是没有赋值，就等于undefined。 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性的值为undefined。 函数没有返回值，默认返回undefined。 1(function(a,b)&#123;console.log(b)&#125;)(1) //undefined","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"浅谈URI和URL及URN的区别和联系","date":"2016-06-13T05:18:03.000Z","path":"2016/06/13/浅谈URI和URL及URN的区别和联系/","text":"对于URL,大家都比较熟悉，其他两个词就比较陌生了。URI、URL和URN是识别、定位和命名互联网上的资源的标准途径。1989年Tim Berners-Lee发明了互联网（World Wide Web）。WWW被认为是全球互连的实际的和抽象的资源的集合–它按需求提供信息实体–通过互联网访问。实际的资源的范围从文件到人，抽象的资源包括数据库查询。 因为要通过多样的方式识别资源（人的名字可能相同，然而计算机文件只能通过唯一的路径名称组合访问），所以需要标准的识别WWW资源的途径。为了满足这种需要，Tim Berners-Lee引入了标准的识别、定位和命名的途径：URI、URL和URN。 URI：Uniform Resource Identifier，统一资源标识符； URL：Uniform Resource Locator，统一资源定位符； URN：Uniform Resource Name，统一资源名称。 在这个体系中的URI、URL和URN是彼此关联的。URI的范畴位于体系的顶层，URL和URN的范畴位于体系的底层。这种排列显示URL和URN都是URI的子范畴。 三者中，其中URL和URI特别容易混淆。 URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。 URL的格式由下列三部分组成： 协议（或称为服务方式）； 存有该资源的主机IP地址（有时也包括端口号）； 主机资源的具体地址。如目录和文件名等。 第一部分和第二部分之间用”：//”符号隔开，第二部分和第三部分用”/”符号隔开。第一部分和第二部分是不可缺少的，第三部分有时可以省略。目前最大的缺点是当信息资源的存放地点发生变化时，必须对URL作相应的改变。因此人们正在研究新的信息资源表示方法。 URI是以某种统一的（标准化的）方式标识资源的简单字符串，一般由三部分组成： 访问资源的命名机制。 存放资源的主机名。 资源自身的名称，由路径表示。 典型情况下，这种字符串以scheme开头，语法如下：1[scheme:] scheme-specific-part http://www.google.com，其中http是scheme，//www.google.com是 scheme-specific-part，并且它的scheme与scheme-specific-part被冒号分开了。 有的URI指向一个资源的内部。这种URI以”#”结束，并跟着一个anchor标志符（称为片断标志符）。相对URI不包含任何命名规范信息。它的路径通常指同一台机器上的资源。相对URI可能含有相对路径（如：“..”表示上一层路径），还可以包含片断标志符。","tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"JS中Math.ceil() 、Math.floor() 、Math.round()的区别","date":"2016-04-18T10:05:06.000Z","path":"2016/04/18/JS中Math-ceil-、Math-floor-、Math-round-的区别/","text":"在工作中经常会使用到Math.ceil() 、Math.floor()和Math.round()这三个函数，并且经常记不清楚产生混淆，这次通过JavaScript: The Definitive Guide, 4th Edition对这三个函数的原型定义的理解，彻底厘清三者的区别。 话不多说，先来一波官方定义： Math.ceil() round a number ==up== Arguments: Any numeric value or expression Returns: The closest integer greater than or equal to x. Math.floor() round a number ==down== Arguments: Any numeric value or expression Returns: The closest integer less than or equal to x. Math.round() round to the nearest ==integer== Arguments: Any number. Returns: The integer closest to x. 总而言之：~~~~ Math.ceil()用作向上取整。 Math.floor()用作向下取整。 Math.round() 我们数学中常用到的四舍五入取整。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"requireJS中的shim——以加载jQuery插件为例","date":"2016-03-28T09:17:59.000Z","path":"2016/03/28/requireJS中的shim——以加载jQuery插件为例/","text":"最近玩了玩requireJS。没有requireJS框架之前，如果我们想使用jquery框架，会在HTML页面中通过script标签加载，这个时候jquery框架生成全局变量$和jQuery等全局变量。如果项目中引用了requireJS框架，采用模块化的方式加载jquery，那么jquery不会再添加全局变量$和 jQuery 。现在问题来了，虽然jquery框架已经开始支持AMD规范，但是jquery的众多插件还是不支持AMD，仍然像以前一样需要使用全局变量$。jquery插件大多都是如下结构： 123(function( $, undefined ) &#123;&#125;)( jQuery ); 如果我们项目中使用了jquery插件，但是jquery框架是通过requireJS加载的（不会添加全局变量$），那怎么完成jquery插件的加载呢？使用传统的方，在HTML页面中通过script加载jquery插件，肯定是不行的。这个时候我们需要使用到requireJS的shim参数，来完成jquery插件的加载。下面我们以加载jquery-ui的slider插件为例： 12345678910111213141516requirejs.config(&#123; shim: &#123; &apos;jquery.ui.core&apos;: [&apos;jquery&apos;], &apos;jquery.ui.widget&apos;: [&apos;jquery&apos;], &apos;jquery.ui.mouse&apos;: [&apos;jquery&apos;], &apos;jquery.ui.slider&apos;:[&apos;jquery&apos;] &#125;, paths : &#123; jquery : &apos;jquery-2.1.1/jquery&apos;, domReady : &apos;require-2.1.11/domReady&apos;, &apos;jquery.ui.core&apos; : &apos;jquery-ui-1.10.4/development-bundle/ui/jquery.ui.core&apos;, &apos;jquery.ui.widget&apos; : &apos;jquery-ui-1.10.4/development-bundle/ui/jquery.ui.widget&apos;, &apos;jquery.ui.mouse&apos; : &apos;jquery-ui-1.10.4/development-bundle/ui/jquery.ui.mouse&apos;, &apos;jquery.ui.slider&apos; : &apos;jquery-ui-1.10.4/development-bundle/ui/jquery.ui.slider&apos; &#125;&#125;); 使用的时候： 123456789101112require([ &apos;jquery&apos;, &apos;domReady&apos;,&apos;jquery.ui.core&apos;,&apos;jquery.ui.widget&apos;,&apos;jquery.ui.mouse&apos;,&apos;jquery.ui.slider&apos;], function($) &#123; $(&quot;#slider&quot; ).slider(&#123; value:0, min: 0, max: 4, step: 1, slide: function( event, ui ) &#123;&#125; &#125;); &#125;); 这样就完美解决了不支持amd规范的插件配置啦。","tags":[{"name":"前端工程","slug":"前端工程","permalink":"http://yoursite.com/tags/前端工程/"}]},{"title":"学习Javascript闭包（Closure）所感","date":"2016-03-13T14:14:17.000Z","path":"2016/03/13/学习Javascript闭包（Closure）所感/","text":"接触编程时间不久，闭包这个问题也困扰了我许久。曾百度google之后无果，解释大多晦涩难懂。随着阅读的增加，对闭包也有了一些自己的较为清晰的理解。所谓的闭包：通俗的说就是能够读取其他函数内部变量的函数。 闭包的作用 读取其他函数内部变量。 将变量存储在内存之中，防止js的垃圾回收机制。 方便传参。 形成“块级作用域”显示和隐藏一些变量，减少全局变量。 闭包的影响： 内存溢出。由于阻止了变量的垃圾回收，使得变量长期存在于内存之中，性能下降，可能会导致内存溢出！ 闭包会在父函数外部，改变父函数内部变量的值。如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 关于闭包的思考题：两道闭包的思考题，由输出的结果加深一下对闭包的理解. eg.1 12345678910var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); eg.21234567891011var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()());","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]}]